# Workflow Enforcement via MCP

**Date:** 2026-02-02  
**Status:** Design proposal  
**Problem:** Workers get stuck, make wrong assumptions, don't test incrementally, hit integration failures

---

## Context

wt handles workspace isolation (worktrees, sessions, auto mode) well, but doesn't enforce workflow discipline. Workers:
- Write 200 lines before testing, fail at the end, waste the run
- Hit ambiguity (e.g., "should CSV dedupe on X or Y?"), guess wrong instead of pausing to ask
- Don't understand architecture patterns (auth flow, service layer, test conventions)
- Debug spiral — retry same approach 5x instead of rolling back and trying differently
- Scope creep — "build CSV import" spawns 10 rabbit holes, no discipline to park P2

**Current wt limits:**
- Unstructured communication (tmux send-keys = raw text)
- No bidirectional signaling (worker can't easily signal "stuck" or "need clarification")
- No programmatic workflow enforcement (can't block on checkpoint, can't validate test passed)

---

## Solution: MCP-Based Control

Add MCP server (`wt-mcp`) that hub runs. Workers connect to it for structured control.

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                          HUB                                 │
│  (Your orchestration session)                               │
│                                                              │
│  - Runs wt-mcp server (localhost:8765)                      │
│  - Spawns workers: wt new <bead>                             │
│  - Sends checkpoints, validates progress                     │
│  - Handles pause/resume, stuck detection                     │
└─────────────────────────────────────────────────────────────┘
         │
         │ MCP server (structured commands)
         ▼
┌─────────────────────────────────────────────────────────────┐
│  WORKER SESSION: toast                                       │
│                                                              │
│  Claude Code + wt-mcp client                                 │
│  - Calls report_checkpoint(id, test_result)                  │
│  - Calls request_pause(reason, options)                      │
│  - Calls signal_stuck(attempts, error)                       │
│  - Calls get_bead_context() for acceptance criteria          │
└─────────────────────────────────────────────────────────────┘
```

### MCP Tools (Hub Side)

**Server:** `wt-mcp` running in hub session

```python
@server.tool()
async def report_checkpoint(session_id: str, checkpoint_id: str, test_result: str):
    """Worker reports checkpoint completion"""
    # Validate test passed
    # Commit work
    # Send next checkpoint prompt
    return {"status": "ok", "next_checkpoint": "..."}

@server.tool()
async def request_pause(session_id: str, reason: str, options: list[str]):
    """Worker requests human input for ambiguity"""
    # Notify user (macOS notification, WhatsApp, tmux status)
    # Wait for resume command
    return {"paused": True, "resume_token": "..."}

@server.tool()
async def signal_stuck(session_id: str, attempts: int, last_error: str):
    """Worker signals it's stuck after multiple failed attempts"""
    # Offer: rollback to last checkpoint, pause and ask human, skip checkpoint
    return {"action": "rollback", "to_commit": "abc123"}

@server.tool()
async def get_bead_context(session_id: str):
    """Worker requests bead details, acceptance criteria, architecture context"""
    return {
        "title": "Notes CSV import",
        "acceptance_criteria": [
            "Endpoint POST /import/notes accepts CSV (text, scheduled_at, tags)",
            "Returns 200 with count on success",
            "Returns 400 with validation errors",
            "Dedupes on (text, scheduled_at) tuple"
        ],
        "checkpoints": [
            {"id": "schema-defined", "desc": "CSV schema validated", "test": "curl returns 501"},
            {"id": "parser-works", "desc": "Parser handles valid + invalid", "test": "pytest test_csv_parser.py"},
            {"id": "e2e-works", "desc": "Full flow works", "test": "curl POST + psql check count"}
        ],
        "architecture": "FastAPI routes in app/routes/, services in app/services/, pytest fixtures in tests/conftest.py"
    }

@server.tool()
async def get_architecture_context(project: str):
    """Worker requests codebase architecture patterns"""
    # Return: DB schema, API route structure, service patterns, test conventions
    # Generated by scanning codebase or from ARCHITECTURE.md
    return {
        "schema": "...",
        "routes": "...",
        "services": "...",
        "tests": "..."
    }
```

### Worker Side (Claude Code Session)

**Launch:** `claude --mcp-server http://localhost:8765` (or via config)

**Worker calls tools:**
```python
# After defining schema:
result = await report_checkpoint(
    checkpoint_id="schema-defined",
    test_result="curl POST /import/notes returns 501 (not implemented)"
)

# When ambiguous:
result = await request_pause(
    reason="Should CSV import dedupe on (text, scheduled_at) tuple or just text?",
    options=["tuple", "text only"]
)

# When stuck:
result = await signal_stuck(
    attempts=3,
    last_error="Integration test fails: DB constraint violation on duplicate scheduled_at"
)

# At start:
context = await get_bead_context()
# Use acceptance_criteria, checkpoints, architecture to guide work
```

---

## Workflow Enforcement Flow

### Happy Path (Checkpoints)

1. Hub spawns worker for bead `gw-backend-csv-import`
2. Hub sends initial prompt: "Your first checkpoint: schema-defined. Call get_bead_context() for details."
3. Worker calls `get_bead_context()`, receives acceptance criteria + checkpoints
4. Worker works, defines schema, adds endpoint stub
5. Worker runs test: `curl -X POST /import/notes` → 501
6. Worker calls `report_checkpoint(checkpoint_id="schema-defined", test_result="curl returns 501")`
7. Hub validates test passed, commits work, sends next prompt: "Checkpoint done. Next: parser-works."
8. Repeat for each checkpoint
9. All checkpoints done → bead complete

### Ambiguity (Pause/Resume)

1. Worker hits decision point: "Should dedupe on (text, scheduled_at) or just text?"
2. Worker calls `request_pause(reason="...", options=["tuple", "text only"])`
3. Hub notifies user (macOS notification, WhatsApp: "Worker paused: needs clarification")
4. User runs: `wt resume toast --answer "dedupe on (text, scheduled_at) tuple"`
5. Hub sends answer to worker as next prompt
6. Worker continues with clarification

### Stuck (Rollback/Retry)

1. Worker tries integration test 3 times, all fail
2. Worker calls `signal_stuck(attempts=3, last_error="DB constraint violation")`
3. Hub offers options:
   - [A] Rollback to last checkpoint (parser-works), try different approach
   - [B] Pause and ask human
   - [C] Skip checkpoint, mark as blocked
4. Worker picks (or hub auto-picks based on policy)
5. If rollback: `git reset --hard <checkpoint-commit>`, send prompt: "Previous approach failed. Try differently."

---

## Benefits

**✅ Checkpoint enforcement** — hub won't proceed until worker calls `report_checkpoint` + test passes  
**✅ Pause/resume** — worker can pause instead of guessing  
**✅ Stuck detection** — worker can signal stuck, hub offers rollback  
**✅ Ambiguity handling** — structured pause with options (not free-form)  
**✅ Architecture context** — worker fetches from hub, always up-to-date  
**✅ Bidirectional** — worker can query hub state, not just receive commands  
**✅ Programmatic** — hub can enforce workflow without manual intervention

---

## Implementation Path

### Phase 1: Minimal MCP Server (2 beads)
- Python/Node MCP server with 2 tools: `report_checkpoint`, `get_bead_context`
- Hub runs server, listens on localhost:8765
- Test: spawn worker, worker calls tools, hub validates

### Phase 2: Checkpoint Validation Loop (2 beads)
- Hub blocks on checkpoint until worker reports + test passes
- Auto-commit on checkpoint success
- Send next checkpoint prompt

### Phase 3: Pause/Resume (2 beads)
- Add `request_pause` tool
- Hub notifies user (macOS, tmux status, optional WhatsApp)
- `wt resume --answer` injects answer into worker

### Phase 4: Stuck Detection & Retry (2-3 beads)
- Add `signal_stuck` tool
- Hub offers rollback/pause/skip
- Rollback mechanism (`git reset --hard <checkpoint-commit>`)

### Phase 5: Architecture Context (2 beads)
- Add `get_architecture_context` tool
- Codebase scanner (parse DB schema, routes, services)
- Inject context at worker start

### Phase 6: Skill & Docs (1 bead)
- wt skill update: teach workers when/how to call MCP tools
- Update docs with MCP workflow examples

**Total:** ~10-12 beads, could ship Phase 1-3 (checkpoint loop + pause) in 1-2 days.

---

## Hybrid: Tmux + MCP

**Don't replace tmux — augment it with MCP.**

- **Tmux:** Session persistence, manual attach, kill, resume
- **MCP:** Structured commands, status reporting, workflow enforcement

**Best of both:**
- Hub spawns worker in tmux (persistence, manual intervention if needed)
- Worker connects to wt-mcp server for structured control
- Hub sends checkpoints, validates, pauses/resumes via MCP
- If worker crashes or you need to intervene → attach to tmux session manually

---

## Comparison to Other Approaches

### vs. Pure Skill (Guidance Only)
**Skill:** Teaches Claude checkpoint pattern, but can't enforce it  
**MCP:** Hard enforcement — hub won't proceed without checkpoint signal

### vs. Fork (Hard-Coded Enforcement)
**Fork:** Requires maintaining wt codebase changes  
**MCP:** No wt code changes, just MCP server on the side

### vs. wt Core PRs (Upstreamable)
**PRs:** Need wt maintainer buy-in, may take time  
**MCP:** Build and ship independently, no upstream dependency

---

## Open Questions

1. **MCP client in Claude Code?** Does Claude Code support MCP client mode? Or use wrapper script?
2. **Server lifetime?** Run wt-mcp server once per hub session, or persistent service?
3. **Multi-worker?** One MCP server handles all workers, or one per worker?
4. **Notification channel?** macOS notifications enough, or integrate WhatsApp for mobile alerts?
5. **Test validation?** Run tests in hub or worker? (Worker = faster, hub = more control)

---

## Next Steps

1. **Spike:** Build minimal wt-mcp server with `get_bead_context` tool
2. **Test:** Spawn worker, have Claude call tool manually, verify it works
3. **Validate:** Does MCP client mode work in Claude Code? If not, use wrapper script
4. **Ship Phase 1-3:** Checkpoint loop + pause/resume (biggest impact)
5. **Iterate:** Add stuck detection, architecture context based on real usage

---

**This is the right architecture for workflow enforcement.** MCP gives structured control without forking wt. Hub can enforce discipline, workers can signal state. Together = autonomous coding that actually works.
